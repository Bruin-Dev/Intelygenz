#
# Using gitlab-ci extends to reuse scripts between jobs (https://docs.gitlab.com/ee/ci/yaml/#extends)
#

.terraform_template_deploy_basic_infra: &terraform_template_deploy_basic_infra
  image:
    name: ${CI_REGISTRY}/mettel/docker_images/terraform_0.14_common_utils:${DOCKER_IMAGE_UTILS_VERSION}
    entrypoint:
      - '/usr/bin/env'
      - 'PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'
  script:
    # Iterate over terraform directories in module
    - cd "${MODULE}" || exit 1
    # assign terraform variables
    - export TF_VAR_AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
    - export TF_VAR_EXTERNAL_DNS_HELM_CHART_VERSION=${EXTERNAL_DNS_CHART_V}
    - export TF_VAR_INGRESS_NGINX_HELM_CHART_VERSION=${INGRESS_NGINX_CHART_V}
    - export TF_VAR_METRICS_SERVER_VERSION=${KUBERNETES_METRICS_SERVER_V}
    - export TF_VAR_RELOADER_CHART_VERSION=${RELOADER_CHART_V}
    - export TF_VAR_WHITELISTED_IPS="[${LOAD_BALANCER_WHITELIST}]"
    - export TF_VAR_GRAFANA_ADMIN_USER=${GRAFANA_ADMIN_USER}
    - export TF_VAR_GRAFANA_ADMIN_PASSWORD=${GRAFANA_ADMIN_PASSWORD}
    - >
      for i in $(find . -mindepth 1 -maxdepth 1 -type d | sort | sed 's|^./||' || exit 1); do
          (
              cd "${i}" || exit
              echo "The current Workdir is $i"
              terraform init -backend=true -get=true -input=false
              if [[ ${i} != "0-ecr-repositories" && ${i} != "4-eks-roles" ]]; then
                  terraform workspace new ${TF_VAR_CURRENT_ENVIRONMENT} || terraform workspace select ${TF_VAR_CURRENT_ENVIRONMENT}
              fi
              terraform refresh
              terraform plan && terraform apply -auto-approve
              cd ..
          )
      done
    - cd ${CI_PROJECT_DIR}
    # INSTALL NECESSARY PYTHON LIBRARIES
    - pip3 install -r ci-utils/eks/iam-to-eks-roles/requirements.txt --use-feature=2020-resolver
    # ASSIGN RBAC PERMISSION IN EKS FROM IAM USER ROLES
    - >
      for i in $(echo $IAM_TO_EKS_ROLES | tr ", " "\n"); do
        (
          python3 ci-utils/eks/iam-to-eks-roles/app.py -p mettel-automation --project-role-tag ${i}
        )
      done

.terraform_template_deploy_environment: &terraform_template_deploy_environment
  image:
    name: ${CI_REGISTRY}/mettel/docker_images/terraform_0.14_common_utils:${DOCKER_IMAGE_UTILS_VERSION}
    entrypoint:
      - '/usr/bin/env'
      - 'PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'
  script:
    - mkdir -p output
    # Iterate over terraform directories and subdirectories in module
    - cd ${MODULE} || exit 1
    - >
      for i in $(find . -mindepth 1 -maxdepth 1 -type d | sort | sed 's|^./||' || exit 1); do
          (
              cd "${i}" || exit 1
              echo "Terraform directory $i"
              if [[ ${i} == "0-elasticaches" ]]; then
                for j in $(find . -mindepth 1 -maxdepth 1 -type d | sort | sed 's|^./||' || exit 1); do
                    (
                      if [[ ${j} != "modules" ]]; then
                        cd "${j}" || exit
                        echo "Terraform workspace subdirectory is ${j}"
                        terraform init
                        terraform workspace new "${TF_VAR_ENVIRONMENT}" || terraform workspace select "${TF_VAR_ENVIRONMENT}"
                        terraform refresh
                        terraform plan && terraform apply -auto-approve
                        if [[ ${j} == "0-redis" ]]; then
                          terraform output REDIS_HOSTNAME > ${CI_PROJECT_DIR}/output/redis_hostname.txt
                        elif [[ ${j} == "1-redis-customer-cache" ]]; then
                          terraform output REDIS_CUSTOMER_CACHE_HOSTNAME > ${CI_PROJECT_DIR}/output/redis_customer_cache_hostname.txt
                        elif [[ ${j} == "2-redis-tnba-feedback" ]]; then
                          terraform output REDIS_TNBA_FEEDBACK_HOSTNAME > ${CI_PROJECT_DIR}/output/redis_tnba_feedback_hostname.txt
                        fi
                      fi
                    )
                done
              else
                echo "Module without subdirectories, Terraform workspace is ${i}"
                terraform init
                terraform workspace new ${TF_VAR_ENVIRONMENT} || terraform workspace select ${TF_VAR_ENVIRONMENT}
                terraform refresh
                terraform plan && terraform apply -auto-approve
              fi
              cd ..
          )
      done
    # INSTALL KUBE CONFIG
    - aws eks update-kubeconfig --name ${EKS_CLUSTER_NAME}
    # CREATE NAMESPACE IF IS NECESSARY
    - >
      if [ "$TF_VAR_CURRENT_ENVIRONMENT" == "dev" ]; then
        kubectl create namespace ${TF_VAR_ENVIRONMENT} --dry-run -o yaml | kubectl apply -f -
      fi
  cache:
    policy: push
    key: "necessary-terraform-vars-${CI_COMMIT_REF_SLUG}"
    paths:
      - output